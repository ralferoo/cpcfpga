
Multiplexing the Z80 bus
------------------------

The emulated Z80 core is running at 4MHz, the memory chip can easily be run
at 16MHz (AS6C4008: tAA,tACE=55ns, tOE=0ns, 16MHz cycle is 62.5ns long)

As I want to implement a support Z80 for SD card access, etc, it makes sense
to think about multiplexing this so that the Z80 sees one cycle in 4.

In any case, this analysis will benefit reverse engineering the CPC muxing
used for video memory access.

Instruction read behaviour
--------------------------

r / T1
	Address put on bus
	M1 asserted
f \ T1
	MREQ, RD asserted

r / T2
	GA chooses not to assert WAIT (because M1 low)
f \ T2
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	CPU reads data from bus
	Deasserts MREQ,RD
	Asserts RFSH
f \ T3
	Asserts MREQ

r / T4
	Nothing
f \ T4
	Deasserts MREQ

r / T1
	Deasserts M1 (unless next read is also an instruction)

* In original CPC design, there are no WAITs introduced during an M1 read.

Only T2 is critical. If we drive address, MREQ and RD on rising edge of T2, the
data will be available on rising edge of T3 even on a 16MHz cycle.

Cycles T1, T3 and T4 don't need to use the bus even though the CPU signals are
valid.



Memory read behaviour
---------------------

r / T1
	Address put on bus
f \ T1
	MREQ, RD asserted

r / T2
	GA chooses to assert WAIT (because M1 high)
f \ T2
	CPU checks WAIT, is asserted so next state is T2 again

r / T2a
	GA deasserts WAIT
f \ T2a
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	Nothing
f \ T3
	CPU reads data from bus
	Deasserts MREQ,RD

* In original CPC design, there is 1 WAIT introduced during this read.

T2 and T3 are critical to get right.  If we drive address, MREQ and RD on
rising edge of T2, the data will be available on rising edge of T3 even on a
16MHz cycle.

If we latch the data on the rising edge of T2a, we don't need the data bus
any more, even though the CPU signals are still valid. IT MUST BE AVAILABLE
TO THE CPU ON THE RISING EDGE OF T3 READY TO BE SAMPLED ON FALLING EDGE OF T3!

We need to insert a single wait state, which we can do by asserting on r/T2
and deasserting on r/T2a, so it can be sampled on f/T2.

Cycles T1, T2a and T3 don't need to use memory even though the CPU signals
are valid.


Memory write behaviour
----------------------

r / T1
	Address put on bus
f \ T1
	Data put on bus
	MREQ asserted

r / T2
	GA chooses to assert WAIT (because M1 high)
f \ T2
	CPU checks WAIT, is asserted so next state is T2 again
	CPU asserts WR

r / T2a
	GA deasserts WAIT
f \ T2a
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	Nothing
f \ T3
	CPU reads data from bus
	Deasserts MREQ,WR

* In original CPC design, there is 1 WAIT introduced during this write.

This time, T2 is VERY different to the CPU ideas...

So, in Z80 mindset, data is available, then we write it out...
For the SRAM we should set WE# early to force the data pins to be high-Z,
so use MREQ#=0,RD#=1 to enable WE#.  We could do this at the rising edge
T2 whilst still having them high-Z for us.
At the falling edge of T2, we output our data.
At the rising edge of T2a, we deassert WE#. We can also put the bus back
to high-Z because tDH=0,tWR means we don't need to maintain address or
data after WE# goes back high. The chip takes tOW=5ns to start outputting
again, but we won't need data any time soon so it doesn't matter.

So, recap: we latch data at r/T2 and assert sram WE#, output data to sram
at f/T2 and deassert sram WE# at r/T2a.

We need to insert a single wait state, which we can do by asserting on r/T2
and deasserting on r/T2a, so it can be sampled on f/T2.

Cycles T1, T2a and T3 don't need to use memory even though the CPU signals
are valid.


