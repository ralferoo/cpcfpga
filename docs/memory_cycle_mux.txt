
Multiplexing the Z80 bus
------------------------

The emulated Z80 core is running at 4MHz, the memory chip can easily be run
at 16MHz (AS6C4008: tAA,tACE=55ns, tOE=0ns, 16MHz cycle is 62.5ns long)

As I want to implement a support Z80 for SD card access, etc, it makes sense
to think about multiplexing this so that the Z80 sees one cycle in 4 anyway.

In any case, this analysis will benefit reverse engineering the CPC muxing
used for video memory access as the video needs 2 of 4 cycles for itself.

It's important to also remember that the Z80 owns its bus and its signals
at all times. The gate array can see the bus via a 74LS244 (buffer) and
present data onto the bus via a 74LS373 (latch/buffer).

The Z80 data bus is permanently attached to the data in of the 4764 RAM,
so it must write the data immediately rather than latching it.

If the GA enables the '244, it can spy on the Z80 databus (for setting GA
registers).

If the GA enables the latch of the '373, it can record the output of the
RAM chip (or output from the GA or latch the current Z80 bus, neither of
which happen - and so the GA databus is readonly).

If the GA enables the output of the '373 it can present latched data from
the RAM to the Z80 even when the RAM is now being used for video.


Instruction read behaviour
--------------------------

r / T1
	Address put on bus
	M1 asserted
f \ T1
	MREQ, RD asserted

r / T2
	GA chooses not to assert WAIT (because M1 low)
f \ T2
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	CPU reads data from bus
	Deasserts MREQ,RD
	Asserts RFSH
f \ T3
	Asserts MREQ

r / T4
	Nothing
f \ T4
	Deasserts MREQ

r / T1
	Deasserts M1 (unless next read is also an instruction)

* In original CPC design, there are no WAITs introduced during an M1 read.

Only T2 is critical. If we drive address, MREQ and RD on rising edge of T2, the
data will be available on rising edge of T3 even on a 16MHz cycle.

Cycles T1, T3 and T4 don't need to use the bus even though the CPU signals are
valid.



Memory read behaviour
---------------------

r / T1
	Address put on bus
f \ T1
	MREQ, RD asserted

r / T2
	GA chooses to assert WAIT (because M1 high)
f \ T2
	CPU checks WAIT, is asserted so next state is T2 again

r / T2a
	GA deasserts WAIT
f \ T2a
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	Nothing
f \ T3
	CPU reads data from bus
	Deasserts MREQ,RD

* In original CPC design, there is 1 WAIT introduced during this read.

T2 and T3 are critical to get right.  If we drive address, MREQ and RD on
rising edge of T2, the data will be available on rising edge of T3 even on a
16MHz cycle.

If we latch the data on the rising edge of T2a, we don't need the data bus
any more, even though the CPU signals are still valid. IT MUST BE AVAILABLE
TO THE CPU ON THE RISING EDGE OF T3 READY TO BE SAMPLED ON FALLING EDGE OF T3!

We need to insert a single wait state, which we can do by asserting on r/T2
and deasserting on r/T2a, so it can be sampled on f/T2.

Cycles T1, T2a and T3 don't need to use memory even though the CPU signals
are valid.


Memory write behaviour
----------------------

r / T1
	Address put on bus
f \ T1
	Data put on bus
	MREQ asserted

r / T2
	GA chooses to assert WAIT (because M1 high)
f \ T2
	CPU checks WAIT, is asserted so next state is T2 again
	CPU asserts WR

r / T2a
	GA deasserts WAIT
f \ T2a
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	Nothing
f \ T3
	CPU reads data from bus
	Deasserts MREQ,WR

* In original CPC design, there is 1 WAIT introduced during this write.

This time, T2 is VERY different to the CPU ideas...

So, in Z80 mindset, data is available, then we write it out...
For the SRAM we should set WE# early to force the data pins to be high-Z,
so use MREQ#=0,RD#=1 to enable WE#.  We could do this at the rising edge
T2 whilst still having them high-Z for us.
At the falling edge of T2, we output our data.
At the rising edge of T2a, we deassert WE#. We can also put the bus back
to high-Z because tDH=0,tWR means we don't need to maintain address or
data after WE# goes back high. The chip takes tOW=5ns to start outputting
again, but we won't need data any time soon so it doesn't matter.

So, recap: we latch data at r/T2 and assert sram WE#, output data to sram
at f/T2 and deassert sram WE# at r/T2a.

We need to insert a single wait state, which we can do by asserting on r/T2
and deasserting on r/T2a, so it can be sampled on f/T2.

Cycles T1, T2a and T3 don't need to use memory even though the CPU signals
are valid.


IO behaviour
------------

Not important to us... we are only concerned about concurrency on the Z80 bus.


Our timings
-----------

	Z80					US

r / T1
	Address put on bus
	M1 asserted on instruction cycles
						*** RAM bus available
f \ T1
	MREQ, RD asserted

r / T2
						We assert WAIT=0 if M1=1
						*** RAM bus used for CPU
						Set address lines 
						Start latching RAM output
						Assert WE# if MREQ=0,RD=1
							(tAS=0, this is OK!)
						Set OE on latch if MREQ=0,RD=0
f \ T2
	CPU checks WAIT to add wait state in M1=1

r / T3
	CPU reads data from bus if M1 was 0
	Deasserts MREQ,RD if M1 was 0
	Asserts RFSH if M1 was 0
						We deassert WAIT
	CPU checks WAIT, if M1 was 1, continue
						Stop latching RAM output
						    (or latch on this edge)
						Deassert WE# if we were writing
						Keep OE on latch if MREQ=0,RD=0
						*** RAM bus available
f \ T3
	Asserts MREQ if M1 was 0

r / T4
	Nothing
						*** RAM bus available
f \ T4
	CPU reads data from bus if M1 was 1, RD=0
	Deasserts MREQ,RD

r / T1
	Deasserts M1 (unless next read is also an instruction)



Bus Request / Ack
-----------------

Not used in CPC design



Int Request / Ack
-----------------

MREQ stays high, even though M1 is low..

WAIT sampled at f/T4, not yet sure if we'd want to add any wait states...

Interrupt vector sampled from data bus at r/T5, presumably this is floating
on a GA triggered interrupt...

IORQ and M1 goes high at r/T5, MREQ goes low at f/T5.
Presumably regular 2 cycles of refresh


So, we have a 6 cycle thing which needs an extra 2 wait states to get back
to normal, but I've read some places that these aren't always added...

****** http://www.cpcwiki.eu/forum/programming/interrupt-wait/msg20283/#msg20283

This suggests that the wait states are ignored if they happen at the end of an
instruction that ends with a 2 T-state M-cycle. Question is, how does a long M-
cycle happen???

e.g. LD r,(IX+d) = 19(4,4,3,5,3) -> 4,4,4,4(this is a calc, so can can extra cycle for free),4  (this only takes 5)
c.f. LD r,(HL)   =  7(4,3) ; so LD A,(HL) instr(7E)+mem -> LD A,(IX+n) instr(DD)+instr(7E)+mem(nn)+add(5)+mem
	similarly AND,XOR,OR,CP (IX+nn)

e.g. LD A,I = 2(4,5) instr(ED)+instr(57)+internal -> 3

e.g. PUSH qq = 11(5,3,3) -> instr+mem+mem -> 4

e.g. EX (SP),HL = 19(4,3,4,3,5) -> 6 on CPC


**** INC ss - 6 cycles


TODO: investigate this further!


NMI Request / Ack
-----------------

pp 37 and 38 - suggest that a dummy instruction cycle is issued for the fetch
that would have happened anyway but the value is ignored. Presumably it then
continues with push pc / jp #66 as normal cycles.


HALT
----

HALT is asserted before r/T1 of the next instruction.
A normal instruction cycle occurs, but the data is ignored and treated as 0.
At r/T4, if an interrupt request has happened, HALT is deasserted at f/T4.
The PC then continues as normal.

