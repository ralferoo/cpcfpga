
Multiplexing the Z80 bus
------------------------

The emulated Z80 core is running at 4MHz, the memory chip can easily be run
at 16MHz (AS6C4008: tAA,tACE=55ns, tOE=0ns, 16MHz cycle is 62.5ns long)

As I want to implement a support Z80 for SD card access, etc, it makes sense
to think about multiplexing this so that the Z80 sees one cycle in 4 anyway.

In any case, this analysis will benefit reverse engineering the CPC muxing
used for video memory access as the video needs 2 of 4 cycles for itself.

It's important to also remember that the Z80 owns its bus and its signals
at all times. The gate array can see the bus via a 74LS244 (buffer) and
present data onto the bus via a 74LS373 (latch/buffer).

The Z80 data bus is permanently attached to the data in of the 4764 RAM,
so it must write the data immediately rather than latching it.

If the GA enables the '244, it can spy on the Z80 databus (for setting GA
registers).

If the GA enables the latch of the '373, it can record the output of the
RAM chip (or output from the GA or latch the current Z80 bus, neither of
which happen - and so the GA databus is readonly).

If the GA enables the output of the '373 it can present latched data from
the RAM to the Z80 even when the RAM is now being used for video.


Instruction read behaviour
--------------------------

r / T1
	Address put on bus
	M1 asserted
f \ T1
	MREQ, RD asserted

r / T2
	GA chooses not to assert WAIT (because M1 low)
f \ T2
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	CPU reads data from bus
	Deasserts MREQ,RD
	Asserts RFSH
f \ T3
	Asserts MREQ

r / T4
	Nothing
f \ T4
	Deasserts MREQ

r / T1
	Deasserts M1 (unless next read is also an instruction)

* In original CPC design, there are no WAITs introduced during an M1 read.

Only T2 is critical. If we drive address, MREQ and RD on rising edge of T2, the
data will be available on rising edge of T3 even on a 16MHz cycle.

Cycles T1, T3 and T4 don't need to use the bus even though the CPU signals are
valid.



Memory read behaviour
---------------------

r / T1
	Address put on bus
f \ T1
	MREQ, RD asserted

r / T2
	GA chooses to assert WAIT (because M1 high)
f \ T2
	CPU checks WAIT, is asserted so next state is T2 again

r / T2a
	GA deasserts WAIT
f \ T2a
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	Nothing
f \ T3
	CPU reads data from bus
	Deasserts MREQ,RD

* In original CPC design, there is 1 WAIT introduced during this read.

T2 and T3 are critical to get right.  If we drive address, MREQ and RD on
rising edge of T2, the data will be available on rising edge of T3 even on a
16MHz cycle.

If we latch the data on the rising edge of T2a, we don't need the data bus
any more, even though the CPU signals are still valid. IT MUST BE AVAILABLE
TO THE CPU ON THE RISING EDGE OF T3 READY TO BE SAMPLED ON FALLING EDGE OF T3!

We need to insert a single wait state, which we can do by asserting on r/T2
and deasserting on r/T2a, so it can be sampled on f/T2.

Cycles T1, T2a and T3 don't need to use memory even though the CPU signals
are valid.


Memory write behaviour
----------------------

r / T1
	Address put on bus
f \ T1
	Data put on bus
	MREQ asserted

r / T2
	GA chooses to assert WAIT (because M1 high)
f \ T2
	CPU checks WAIT, is asserted so next state is T2 again
	CPU asserts WR

r / T2a
	GA deasserts WAIT
f \ T2a
	CPU checks WAIT, not asserted next state, so continue to T3

r / T3
	Nothing
f \ T3
	CPU reads data from bus
	Deasserts MREQ,WR

* In original CPC design, there is 1 WAIT introduced during this write.

This time, T2 is VERY different to the CPU ideas...

So, in Z80 mindset, data is available, then we write it out...
For the SRAM we should set WE# early to force the data pins to be high-Z,
so use MREQ#=0,RD#=1 to enable WE#.  We could do this at the rising edge
T2 whilst still having them high-Z for us.
At the falling edge of T2, we output our data.
At the rising edge of T2a, we deassert WE#. We can also put the bus back
to high-Z because tDH=0,tWR means we don't need to maintain address or
data after WE# goes back high. The chip takes tOW=5ns to start outputting
again, but we won't need data any time soon so it doesn't matter.

So, recap: we latch data at r/T2 and assert sram WE#, output data to sram
at f/T2 and deassert sram WE# at r/T2a.

We need to insert a single wait state, which we can do by asserting on r/T2
and deasserting on r/T2a, so it can be sampled on f/T2.

Cycles T1, T2a and T3 don't need to use memory even though the CPU signals
are valid.


IO behaviour
------------

Not important to us... we are only concerned about concurrency on the Z80 bus.

LIES! The CPC does also seem to stretch IO requests. Probably a bug!

IN A,(nn)	3 on CPC	4,3,4		expected, but I think because T1 of last gets pushed forward
OUT (nn),A	3 on CPC			instr+mem(nn)+in(5)

IN r,(C)	4 on CPC	4,4,4
OUT (C),r	4 on CPC

IN[ID]		5		4,5,3,4		so, due to 2nd overrunning
CP[ID]R		5,6	
IN[ID]R		5,6		4,5,3,4 [,5]	2nd overrunning, bus???
OT[ID]R		5,6

Our timings
-----------

	Z80					US

r / T1
	Address put on bus
	M1 asserted on instruction cycles
						*** RAM bus available
f \ T1
	MREQ, RD asserted

r / T2
						We assert WAIT=0 if M1=1
						*** RAM bus used for CPU
						Set address lines 
						Start latching RAM output
						Assert WE# if MREQ=0,RD=1
							(tAS=0, this is OK!)
						Set OE on latch if MREQ=0,RD=0
f \ T2
	CPU checks WAIT to add wait state in M1=1

r / T3
	CPU reads data from bus if M1 was 0
	Deasserts MREQ,RD if M1 was 0
	Asserts RFSH if M1 was 0
						We deassert WAIT
	CPU checks WAIT, if M1 was 1, continue
						Stop latching RAM output
						    (or latch on this edge)
						Deassert WE# if we were writing
						Keep OE on latch if MREQ=0,RD=0
						*** RAM bus available
f \ T3
	Asserts MREQ if M1 was 0

r / T4
	Nothing
						*** RAM bus available
f \ T4
	CPU reads data from bus if M1 was 1, RD=0
	Deasserts MREQ,RD

r / T1
	Deasserts M1 (unless next read is also an instruction)



Bus Request / Ack
-----------------

Not used in CPC design



Int Request / Ack
-----------------

MREQ stays high, even though M1 is low..

WAIT sampled at f/T4, not yet sure if we'd want to add any wait states...

Interrupt vector sampled from data bus at r/T5, presumably this is floating
on a GA triggered interrupt...

IORQ and M1 goes high at r/T5, MREQ goes low at f/T5.
Presumably regular 2 cycles of refresh


So, we have a 6 cycle thing which needs an extra 2 wait states to get back
to normal, but I've read some places that these aren't always added...

****** http://www.cpcwiki.eu/forum/programming/interrupt-wait/msg20283/#msg20283

This suggests that the wait states are ignored if they happen at the end of an
instruction that ends with a 2 T-state M-cycle. Question is, how does a long M-
cycle happen???

e.g. LD r,(IX+d) = 19(4,4,3,5,3) -> 4,4,4,4(this is a calc, so can can extra cycle for free),4  (this only takes 5)
c.f. LD r,(HL)   =  7(4,3) ; so LD A,(HL) instr(7E)+mem -> LD A,(IX+n) instr(DD)+instr(7E)+mem(nn)+add(5)+mem
	similarly AND,XOR,OR,CP (IX+nn)

e.g. LD A,I = 2(4,5) instr(ED)+instr(57)+internal -> 3

e.g. PUSH qq = 11(5,3,3) -> instr+mem+mem -> 4

e.g. EX (SP),HL = 19(4,3,4,3,5) -> 6 on CPC


**** INC ss - 6 cycles


TODO: investigate this further!


NMI Request / Ack
-----------------

pp 37 and 38 - suggest that a dummy instruction cycle is issued for the fetch
that would have happened anyway but the value is ignored. Presumably it then
continues with push pc / jp #66 as normal cycles.


HALT
----

HALT is asserted before r/T1 of the next instruction.
A normal instruction cycle occurs, but the data is ignored and treated as 0.
At r/T4, if an interrupt request has happened, HALT is deasserted at f/T4.
The PC then continues as normal.



IMPLEMENTATION
--------------

This is approaching it from the external to CPU perspective...

In T1, we have no information about what's going on. But we do have full use
of the RAM.

At the rising edge of T2, the following can be true:
	
M1	MREQ	IORQ	RD	WR

0	0	1	0	1	instruction read coming (4 cycles)
1	0	1	0	1	memory read coming	(3 cycles)
1	0	1	1	1	memory write coming	(3 cycles)

1	1	1	1	1	io coming / bus idle	(4 cycles)
0	1	1	1	1	interrupt request	(5 cycles)

Note, we can't yet do anything about the IO request...

All the cases we can deal with, in fact, are when MREQ=0.
r_T2:
MREQ=0 =>
	set WAIT=not M1
	set address lines
	ram.WE#=0,ram.din=z80.dout if MREQ=0,RD=1
	continue to r_T3
MREQ=1 =>
	continue to r_idle_T3


r_T3:
	set WAIT=1
	z80.dIN = ram.dout if MREQ=0,RD=0
	set ram.WE#=1
	CAN USE THE RAM FOR VIDEO
	continue to r_T4

r_T4:
	continue to r_T1

r_T1:
	CAN USE THE RAM FOR VIDEO
	continue to r_T2

r_idle_T3:
	-- we got here because the bus was idle, and IO is about to come or we're processing an interrupt request
M1=0 =>
	CAN USE THE RAM FOR VIDEO
	continue to r_intreq_T4		-- nothing we can do here
MREQ=0 =>
	POTENTIAL COLLISION
	WAIT=0
	continue to r_collision_T4
	CAN USE RAM FOR VIDEO
IORQ=0 =>
	DO WE ADD A WAIT CYCLE?
	WAIT=0
	continue to r_collision_T4
	CAN USE RAM FOR VIDEO

r_intreq_T4:
	-- started the interrupt request phase
IORQ=0 =>
	COLLISION





gate array inputs:

IORQ, M1, RD, MREQ

	state	mode	M1	MREQ	IORQ	RD	WR	WAIT	newmode
	--------------------------------------------------	---------------
	T2	idle	1	1	1	x	x	no	idle	idle bus (or io coming)
	T3	idle	x	1	1	x	x	no	idle	idle bus
	T4	idle	x	1	1	x	x	no	idle	idle bus (or delayed io)
	T1	idle	x	1	1	x	x	no	idle	idle bus
	
	T2	idle	0	0	x	x	x	no	mem	instruction fetch		(1)
	T2	idle	1	0	x	x	x	yes	mem	read/write, add wait state	(1)

	T3	mem	x	0 (x)	x	x	x	no	mem	latch data			(2)
	T4	mem	x	x	x	x	x	no	mem	data for read is latched
	T1	mem	x	1	1	1	1	no	idle	bus should be returned to normal

	T3	idle	x	0	x	x	x	yes	idle	memory request out of place
	T4	idle	x	0	x	x	x	yes	idle	memory request out of place
	T1	idle	x	0	x	x	x	yes	idle	memory request out of place

	T3	idle	x	1	0	x	x	yes	idle	io request out of place		CHECK
	T4	idle	x	1	0	x	x	yes	idle	io request out of place		CHECK
	T1	idle	x	1	0	x	x	yes	idle	io request out of place		CHECK

	T2	idle	x	1	0	x	x	yes	io	io that's been delayed 3 cycles already! (3)
	T3	io	x	1	0	x	x	no	io	io that's been delayed 4 cycles (4)
	T4	io	x	1	0	x	x	no	io	io that's been delayed 4 cycles (5)
	T4	io	x	1	1	x	x	no	idle	bus should be back to normal

	T2	idle	0	1	1	x	x	no	intreq	intreq coming
	T3	intreq	0	1	1	x	x	no	intreq	intreq coming (6)
	T4	intreq	0	1	0	x	x	yes	intreq	int vector request (7)
	T1	intreq	0	1	0	x	x	yes	intreq	int vector request (8)

	T2	intreq	0	1	0	x	x	no	intreq	int vector request (9)
	T3	intreq	0	0	1	1	x	no	irfrsh	1st refresh cycle (10)
	T4	irfrsh	x	0	1	1	x	no	irfrsh	2nd refresh cycle
	T1	irfrsh	x	1	1	1	1	no	idle	bus should be returned to normal

basically, all the rules boil down to:	
	if mode=IDLE and (IORQ=0 or MREQ=0):
		if state=T2, WAIT=not M1, nextmode=NOTIDLE
		else,  WAIT=0
	if mode=NOTIDLE:
		if state=T1, nextmode=IDLE
		WAIT=1

	state	mode	miorq		wait	nextmode
	T2	IDLE	yes		!m1	NOTIDLE
	*	IDLE	yes		yes	IDLE

	T1	NOTIDLE	*		miorq	IDLE
	*	NOTIDLE	*		miorq	NOTIDLE
	T2	NOTIDLE	error!		miorq	NOTIDLE



(1)	WAIT=not M1
	ram.addr=z80.addr
	ram.din=z80.dout
	ram.we=not z80.rd	(as WR not yet asserted)
	ram.WE#=0,ram.din=z80.dout if MREQ=0,RD=1

(2)	WAIT=1
	z80.din=ram.dout
	ram.we=1
	CAN USE THE RAM FOR VIDEO

(3)	this rising edge of T2 is really a very delayed TW rising edge
	not entirely sure why it gets further delayed on CPC, we don't need the CPU bus for video!
	io.din=z80.dout

(4)	this rising edge of T3 is a rising edge of the 2nd TW in zilog language
	trigger IO processing on this edge... so it's not clock loaded on (3)

(5)	this rising edge of T4 is a rising edge of T3 in zilog language
	z80.din=io.dout

(6)	this is the first TW in zilog language

(7)	this is like T1 of an instruction fetch, (2nd TW and deferrable) so defer it 2 cycles

(8)	this is like T1 of an instruction fetch, (2nd TW and deferrable) so defer it 2 cycles

(9)	this is like T2 of an instruction fetch, (2nd TW in zilog language) except iorq brought low instead of mreq

(10)	this is like T3 of an instruction fetch, except iorq brought low instead of mreq








M1	MREQ	IORQ	RD	WR

0	0	1	0	1	instruction read coming (4 cycles)
1	0	1	0	1	memory read coming	(3 cycles)
1	0	1	1	1	memory write coming	(3 cycles)

1	1	1	1	1	io coming / bus idle	(4 cycles)
0	1	1	1	1	interrupt request	(5 cycles)

Note, we can't yet do anything about the IO request...

